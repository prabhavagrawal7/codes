{
	"boilerplate": {
		"prefix": "boilerplate",
		"body": [
		  "#include \"bits/stdc++.h\"",
		  "using namespace std;",
		  "#define ll int64_t",
		  "",
		  "// Uncomment them for optimisations",
		  "// #pragma GCC optimize(\"Ofast\")",
		  "// #pragma GCC target(\"avx2\")",
		  "",
		  "// for segment tree",
		  "// #define mid (start+end)/2",
		  "// #define lnode (node*2+1)",
		  "// #define rnode (node*2+2)",
		  "",
		  "// printing bullshits open",
		  "template <typename _A, typename _B> ostream &operator<<(ostream &os, const pair<_A, _B> &p) { os ",
		  "<< \"[\" << p.first << \",\" << p.second << \"]\"; return os; } template <typename T, typename = void> ",
		  "struct is_iterable : false_type { }; template <typename T> struct is_iterable<T, void_t<decltype",
		  "(begin(declval<T &>())), decltype(end(declval<T &>()))>> : true_type { }; template <typename T> ",
		  "using is_string = is_same<decay_t<T>, string>; template <typename T> constexpr bool is_iterable_v ",
		  "= is_iterable<T>::value; template <typename T> typename enable_if<!is_iterable_v<T>, void>::type ",
		  "__print(T &&container) { cout << container; } template <typename T> typename ",
		  "enable_if<is_iterable_v<T> && !is_string<T>::value, void>::type __print(T && container) { for(auto ",
		  "itr = container.begin(); itr != container.end(); itr++) { __print(*itr); if(next(itr) != container.",
		  "end()) cout << ' '; } } template <typename T> typename enable_if<is_string<T>::value, void>::type ",
		  "__print(T &&string_container) { cout << string_container; } template <typename T> typename ",
		  "enable_if<is_same<T, const char *>::value, void>::type __print(T &&string_container) { cout << ",
		  "string_container; } template <size_t N> void __print(const char (&str)[N]) { cout << str; } ",
		  "template <typename... T> inline void print(T &&...args) { ((__print(args), cout << \" \"), ...); ",
		  "cout << endl; } template <typename... T> inline void printl(T &&...args) { ((__print(args), cout ",
		  "<< \" \"), ...); }",
		  "// printing bullshits close",
		  "",
		  "#define popcount(x) __builtin_popcountll(x)",
		  "#define clz(x) (63 - __builtin_clzll(x)) // count leading zeros",
		  "#define ctz(x) __builtin_ctzll(x)\t\t// count trailing zeros",
		  "#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME",
		  "#define range(...) GET_MACRO(__VA_ARGS__, r4, r3, r2, r1)(__VA_ARGS__)",
		  "#define r4(var, start, stop, step) for (ll var = start; step > 0 ? var < stop : var > stop; var = var + step)",
		  "#define r3(var, start, stop) for (ll var = start; var < stop; ++var)",
		  "#define r2(var, stop) for (ll var = 0; var < stop; ++var)",
		  "#define r1(stop) for (ll start_from_0 = 0; start_from_0 < stop; ++start_from_0)",
		  "#define newint(...) \\",
		  "\tll __VA_ARGS__; \\",
		  "\ttake_input(__VA_ARGS__)",
		  "#define min(...) min({__VA_ARGS__})",
		  "#define max(...) max({__VA_ARGS__})",
		  "#define give(...)\t\t   \\",
		  "\tdo\t\t\t\t\t  \\",
		  "\t{\t\t\t\t\t   \\",
		  "\t\tprint(__VA_ARGS__); \\",
		  "\t\treturn;\t\t\t \\",
		  "\t} while (false)",
		  "#define endl \"\\n\"",
		  "#define FULL_INF numeric_limits<double>::infinity()",
		  "#define INF INT64_MAX",
		  "#define INT_INF INT32_MAX",
		  "#define ld long double",
		  "#define V vector",
		  "#define P pair",
		  "#define S set",
		  "#define MS multiset",
		  "#define M map",
		  "#define UM unordered_map",
		  "#define US unordered_set",
		  "#define MM multimap",
		  "#define mt make_tuple",
		  "#define mp make_pair",
		  "#define pb push_back",
		  "#define ppb pop_back",
		  "#define pf push_front",
		  "#define ppf pop_front",
		  "#define FAST ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
		  "#define all(a) a.begin(), a.end()",
		  "#define db(x) cout << #x << \" = \" << x << \"\\n\"",
		  "string db_bin(ll n)",
		  "{",
		  "\tstring ans;",
		  "\twhile (n)",
		  "\t{",
		  "\t\tans.push_back((n & 1) + '0');",
		  "\t\tn >>= 1;",
		  "\t}",
		  "\treverse(all(ans));",
		  "\treturn ans;",
		  "}",
		  "#define newstring(str) \\",
		  "\tstring str;\t\t\\",
		  "\tcin >> str;",
		  "#define foreach(a, x) for (auto &&a : x)",
		  "const ld pi = acos(-1);",
		  "typedef vector<string> vs;",
		  "typedef pair<ll, ll> pii;",
		  "typedef vector<ll> vi;",
		  "typedef map<ll, ll> mii;",
		  "typedef set<ll> si;",
		  "typedef vector<vector<ll>> vvi;",
		  "template <typename... T>",
		  "inline void take_input(T &&...args) { ((cin >> args), ...); }",
		  "vi inputvec(ll n, ll start = 0)",
		  "{",
		  "\tvi vec(n);",
		  "\trange(i, start, n) cin >> vec[i];",
		  "\treturn vec;",
		  "}",
		  "template <typename T>",
		  "inline bool btn(T a, T b, T c)",
		  "{",
		  "\tif ((a <= b && b <= c) || (a >= b && b >= c))",
		  "\t\treturn true;",
		  "\treturn false;",
		  "}",
		  "template <typename T>",
		  "istream &operator>>(istream &is, V<T> &v)",
		  "{",
		  "\trange(i, v.size()) { is >> v[i]; }",
		  "\treturn is;",
		  "}",
		  "inline ld TLD(ll n) { return n; }",
		  "ll gcd(ll __m, ll __n) { return __n == 0 ? __m : gcd(__n, __m % __n); }",
		  "const ll mod = 1000000007;",
		  "// const ll mod = 998244353;",
		  "inline ll rs(ll n) { return (n %= mod) >= 0 ? n : n + mod; }",
		  "// define rll above this",
		  "#ifndef __RLL__",
		  "ll power(ll x, ll y)",
		  "{",
		  "\tx %= mod, y %= mod - 1;",
		  "\tll res = 1;",
		  "\twhile (y)",
		  "\t{",
		  "\t\tif (y & 1LL)",
		  "\t\t\tres = (res * x) % mod;",
		  "\t\ty >>= 1;",
		  "\t\tx = (x * x) % mod;",
		  "\t}",
		  "\treturn res % mod;",
		  "}",
		  "ll inv(ll n) { return power(n, mod - 2); }",
		  "#endif",
		  "/* ----------------------------------------------------------------------------------------------*/",
		  "",
		  "void func()",
		  "{",
		  "\t${0}",
		  "}",
		  "int main()",
		  "{",
		  "\tFAST;",
		  "\tnewint(t);",
		  "\trange(t)",
		  "\t{",
		  "\t\tfunc();",
		  "\t}",
		  "}",
		  ""
		],
		"description": "boilerplate"
	  },
	"rlonglong": {
		"prefix": "rlonglong",
		"body": [
			"#define __RLL__ 1",
			"template <typename T> ll power(T, ll);",
			"inline ll inv(ll n) { return power(n, mod - 2); }",
			"class rll",
			"{",
			"private:",
			"\tint64_t val;",
			"",
			"public:",
			"\trll power(unsigned long long y) { return ::power(val, y); }",
			"\trll div_by(ll x) { return val / x; }",
			"\tfriend inline istream &operator>>(istream &cc, rll &a) { return (cc >> a.val), (a += 0), cc; }",
			"\toperator int64_t() const { return val; }",
			"\ttemplate <typename T>",
			"\trll(T _val) : val(rs(_val)) {}",
			"\trll() : val(0) {}",
			"\t// arithmetic operators",
			"\tinline rll operator++() { return val++; }",
			"\tinline rll operator--() { return val--; }",
			"\tinline rll operator+(rll a) { return rs(val + a.val); }",
			"\tinline rll operator-(rll a) { return rs(val - a.val); }",
			"\tinline rll operator*(rll a) { return rs(a.val * val); }",
			"\tinline rll operator/(rll a) { return inv(a) * *this; }",
			"\tinline rll operator%(rll a) { return rs(val % a.val); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator+(T &&a, U &&b) { return rll(a) + rll(b); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator-(T &&a, U &&b) { return rll(a) - rll(b); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator*(T &&a, U &&b) { return rll(a) * rll(b); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator/(T &&a, U &&b) { return rll(a) / rll(b); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator%(T &&a, U &&b) { return rll(a) % rll(b); }",
			"",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator+=(T &&a, U &&b) { return a = rll(a) + rll(b); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator-=(T &&a, U &&b) { return a = rll(a) - rll(b); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator*=(T &&a, U &&b) { return a = rll(a) * rll(b); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator/=(T &&a, U &&b) { return a = rll(a) / rll(b); }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline rll operator%=(T &&a, U &&b) { return a = rll(a) % rll(b); }",
			"",
			"\t// logical operators",
			"\tinline bool operator<(rll &&a) { return (val < a.val); }",
			"\tinline bool operator>(rll &&a) { return (val > a.val); }",
			"\tinline bool operator<=(rll &&a) { return (val <= a.val); }",
			"\tinline bool operator>=(rll &&a) { return (val >= a.val); }",
			"\tinline bool operator!() { return !val; }",
			"",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline bool operator<(T &&a, U &&b) { return (ll)a < (ll)b; }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline bool operator>(T &&a, U &&b) { return (ll)a > (ll)b; }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline bool operator<=(T &&a, U &&b) { return (ll)a <= (ll)b; }",
			"\ttemplate <typename T, typename U>",
			"\tfriend inline bool operator>=(T &&a, U &&b) { return (ll)a >= (ll)b; }",
			"};",
			"template <typename T>",
			"ll power(T _x, ll _y)",
			"{",
			"\trll x = _x;",
			"\t_y %= mod - 1;",
			"\trll res = 1;",
			"\twhile (_y)",
			"\t{",
			"\t\tif (_y & 1LL)",
			"\t\t\tres *= x;",
			"\t\t_y >>= 1;",
			"\t\tx = x * x;",
			"\t}",
			"\treturn res;",
			"}",
			""
		],
		"description": "rlonglong"
	},
	"sieve": {
		"prefix": "sieve",
		"body": [
			"const ll range = 1000006;",
			"vi prime(range + 1, 1);",
			"void sieve()",
			"{",
			"\tfor (int p = 2; p * p <= range; ++p)",
			"\t{",
			"\t\tif (prime[p] == 1)",
			"\t\t{",
			"\t\t\tfor (int i = p * p; i <= range; i += p)",
			"\t\t\t\tif (prime[i] == 1)",
			"\t\t\t\t\tprime[i] = p; ",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "sieve"
	},
	"segment_tree": {
		"prefix": "segment_tree",
		"body": [
			"struct seg",
			"{",
			"#define mid ((start + end) >> 1)",
			"#define lnode (node * 2 + 1)",
			"#define rnode (node * 2 + 2)",
			"\tV<vi> tree;",
			"\tll n;",
			"\tseg(ll n)",
			"\t{",
			"\t\tthis->n = n;",
			"\t\ttree.assign(1LL << (clz(n) + 2), {0, 0});",
			"\t}",
			"\tvoid push(ll node, ll start, ll end)",
			"\t{",
			"\t\t// critical",
			"\t}",
			"\tvoid opr(vi &a, vi &b)",
			"\t{",
			"\t\t// critical",
			"\t}",
			"\tvoid update(ll l, ll r, ll A, ll D, ll node, ll start, ll end)",
			"\t{",
			"\t\tif (r < start || end < l)",
			"\t\t\treturn;",
			"\t\telse if (l <= start && end <= r)",
			"\t\t{",
			"\t\t\t// critical",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tpush(node, start, end);",
			"\t\tupdate(l, r, A, D, lnode, start, mid);",
			"\t\tupdate(l, r, A + D * (mid - start + 1), D, rnode, mid + 1, end);",
			"\t\ttree[node] = opr(tree[lnode], tree[rnode]);",
			"\t}",
			"\tll rfind(ll l, ll r, ll val, ll node, ll start, ll end)",
			"\t{",
			"\t\tif (r < start || end < l)",
			"\t\t\treturn neutral_element;",
			"\t\telse if (l <= start && end <= r)",
			"\t\t{",
			"\t\t\t// critical",
			"\t\t\treturn tree[node];",
			"\t\t}",
			"\t\tpush(node, start, end);",
			"\t\treturn opr(rfind(l, r, val, lnode, start, mid),",
			"\t\t\t\t   rfind(l, r, val, rnode, mid + 1, end));",
			"\t}",
			"};"
		],
		"description": "segment_tree"
	}
}